# 24. 클로저

- 2024.7.24

## 🏷 렉시컬 스코프

```
- 자바스크립트 엔진은 함수 정의 위치에 따라 상위 스코프(렉시컬 스코프)를 결정
- 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 정의된 위치에 의해 지정
```

<br />

## 🏷 함수 객체의 내부 슬롯 [[Environment]]

```
- 상위 스코프: 함수 객체의 내부 슬롯 [[Environment]]에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조
- 함수 객체는 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조를 기억함
- 외부 렉시컬 환경에 대한 참조 => 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조가 할당
```

<br />

## 🏷 클로저와 렉시컬 환경

```
- 클로저: 중첩 함수가 외부 함수보다 더 오래 유지되는 경우 중첩 함수는 종료된 외부 함수의 변수 참조 가능
- 외부 함수 종료 시 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 렉시컬 환경까지 소멸되지는 않는다.
- 이론적으로 모든 함수는 클로저
- 그러나 어떤 함수는 상위 스코프의 어떤 식별자도 참조하지 않는다 => 이는 클로저라고 할 수 없다.
- 중첩 함수가 상위 스코프의 식별자를 참조하고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우 => 클로저
```

<br />

## 🏷 클로저의 활용

```
- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용
- 즉, 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용
```

```jsx
const increase = (function () {
  let num = 0;

  return function () {
    return ++num;
  };
})();

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

```
- 위 코드에서 즉시 실행 함수는 호출 이후 소멸되지만 함수가 반환한 클로저는 increase 변수에 할당되어 호출된다
- 즉시 실행 함수는 한번만 실행되므로 num 변수가 초기화되는 일은 없고 num은 은닉된 private 변수이므로 안정적이다 (클로저 사용)
- 불변성을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하고 오류를 피하기 위해 클로저를 적극적으로 사용한다
```

<br />

## 🏷 캡슐화와 정보 은닉

```
- 캡슐화: 객체 상태를 나타내는 프로퍼티와 프로퍼티를 참조 및 조작할 수 있는 메서드를 하나로 묶는 것
- 정보 은닉: 캡슐화를 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하는 것
- 정보 은닉 장점: 객체의 상태 변경 방지, 정보 보호, 결합도 낮추기
- 타 언어에서는 접근 제한자(private, public, protected) 지원, 그러나 자바스크립트는 아님
- 변수명 앞에 언더스코어(_)를 붙일 경우 private으로 동작
- 자바스크립트는 정보 은닉을 완전하게 지원하지 않고, 자유 변수나 Symbol, WeakMap으로 private property를 흉내낼 수 있다.
- TC39 stage 3에서 클래스에 private 필드를 정의하는 새로운 표준사항 제안
```

```jsx
// private 변수 예시 (그러나 완벽하지는 않은..)

const Person = function () {
  let _age = 0;

  function Person(name, age) {
    this.name = name;
    _age = age;
  }

  Person.prototype.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };

  return Person;
};

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined
```

<br />

## 🏷 자주 발생하는 실수

```jsx
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

```
- 위 코드에서 0, 1, 2를 반환할 것으로 기대하나 실제로는 3을 반환한다.
- var 키워드로 선언한 i 변수는 함수 레벨 스코프를 가져 전역 변수이기 때문이고, funcs 배열의 요소로 추가한 함수를 호출하면 전역 변수 i를 참조하기 때문에 현재 i의 값 3을 반환한다.
- 위와 같은 문제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 var 키워드로 선언한 변수가 전역 변수가 되어 발생한 현상
- var 대신 let 키워드를 사용하거나 고차 함수를 사용하면 해결할 수 있다.
```
