# 19. 프로토타입

- 2024.7.20

## 🏷 객체 지향 프로그래밍

> 객체의 집합으로 프로그램일 표현하려는 프로그래밍 패러다임

```
- 속성: 실체를 인식하거나 구별 가능
- 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 표현 => 추상화
- 따라서 객체는 속성을 통해 여러개의 값을 하나의 단위로 구성하고 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적 자료 구조
```

<br />

## 🏷 상속과 프로토타입

```
- 상속: 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용하는 것
- 자바스크립트는 "프로토타입"을 기반으로 상속얼 구현한다.
- 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해두면 별도의 추가적인 구현이 필요하지 않다.
```

<br />

## 🏷 프로토타입 객체

```
- 프로토타입 객체는 객체 간 상속을 구현하기 위해 사용
- 모든 객체는 하나의 프로토타입을 가지고 생성자 함수와 연결되어있다.
```

### 3.1 \_\_proto\_\_ 접근자 프로퍼티

```
- 모든 객체는 __proto__ 접근자 프로퍼티를 통해 [[Prototype]] 내부 슬롯에 간접적으로 접근 가능
```

#### \_\_proto\_\_는 접근자 프로퍼티다.

```
- 접근자 프로퍼티는 자체적으로 [[Value]] 프로퍼티를 갖지 않고 [[Get]], [[Set]] 프로퍼티 어트리뷰트로 구성된 프로퍼티이다.
- __proto__는 [[Get]], [[Set]]을 통해 프로토타입을 취득하거나 할당한다.
```

#### \_\_proto\_\_ 접근자 프로퍼티는 상속을 통해 사용된다.

```
- __proto__ 접근자 프로퍼티는 Object.prototype의 프로퍼티이고, 모든 객체는 상속을 통해 Object.prototype.__proto_ 접근자 프로퍼티를 사용할 수 있다.
```

#### \_\_proto\_\_ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유

```
- 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하느 이유: 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해
- 서로가 자신의 프로토타입이 되면 종점이 존재하지 않기 때문에 무한 루프에 빠지게 된다.
- 이를 해결하기 위해서는 \_\_proto\_\_ 접근자 프로퍼트를 통해 프로토타입에 접근 및 교체하도록 구현되어있다.
```

#### \_\_proto\_\_ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.

```
- __proto__ 접근자 프로퍼티는 ES5까지 ECMAScript에 포함되지 않은 비표준
- 모든 객체가 __proto__ 접근자 프로퍼티를 쓸 수 있는 것은 아니기 때문에 권장하지 않음
- 프로토타입 참조를 취득하고 싶은 경우는 Object.getPrototypeOf 메서드 사용
- 프로토타입 교체하고 싶은 경우 Object.setPrototypeOf 메서드 사용
```

### 3.2 함수 객체의 prototype 프로퍼티

```
- 함수 객체만이 소유하는 prototype 프로퍼티 = 생성자 함수가 생성할 프로토타입
- non-constructor인 화살표함수와 ES6 메서드 축약 표현으로 정의한 메서드는 프로토타입을 생성하지 않음
- 결국, __proto__ 접근자 프로퍼티 == prototype 프로퍼티
```

| 구분                          | 소유        | 값                | 사용 주체   |
| ----------------------------- | ----------- | ----------------- | ----------- |
| \_\_proto\_\_ 접근자 프로퍼티 | 모든 객체   | 프로토타입의 참조 | 모든 객체   |
| prototype 프로퍼티            | constructor | 프로토타입의 참조 | 생성자 함수 |

### 3.3 프로토타입의 constructor 프로퍼티의 생성자 함수

```
- constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.
```

<br />

## 🏷 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

```
- Object 생성자 함수 호출과 객체 리터럴은 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하는 점에서 동일하나 new.target의 확인이나 프로퍼티를 추가하는 등은 다르다.
- 리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다. 따라서 리터럴 표기법에 의해 생성된 객체도 "가상의 생성자 함수"를 갖는다.
```

<br />

## 🏷 프로토타입의 생성 시점

```
- 생성 시점: 생성자 함수가 생성되는 시점에 더불어 생성
```

### 5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

```
- consturctor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 함께 생성됨
- non-constructor는 프로토타입이 생성되지 않는다.
```

### 5.2 빌트인 생성자 함수와 프로토타입 생성 시점

```
- 빌트인 생성자 함수도 생성되는 시점에 프로토타입이 함께 생성되며, 이 프로토타입은 prototype 프로퍼티에도 바인딩된다.
```

<br />

## 🏷 객체 생성 방식과 프로토타입의 결정

```
- 세부적인 객체 생성 방식에 차이는 있으나 모두 OrdinaryObjectCreate에 의해 생성되고, 프로토타입은 전달되는 이수에 의해 결정된다.
```

### 6.1 객체 리터럴에 의해 생성된 객체의 프로토타입

```
- 객체를 생성할 때 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 Object.prototype이다.
```

### 6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입

```
- Object 생성자 함수를 인수 없이 호출 시 빈 객체 생성
- Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 OrdinaryObjectCreate가 호출되고, Object.prototype이 전달된다.
```

### 6.3 생성자 함수에 의해 생성된 객체의 프로토타입

```
- new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 OrdinaryObjectCreate가 호출되고, 생성자 함수의 prototype에 바인디오디어있는 객체가 전달된다.
```

<br />

## 🏷 프로토타입 체인

```
- 프로토타입 체인: 객체의 프로퍼티에 접근하려고 할 떄 [[Prototype]]의 참조를 따라 부모의 프로토타입의 프로퍼티를 순차적으로 검색하는 것
- 프로토타입의 프로토타입은 언제나 Object.prototype이고, 모든 객체는 Object.prototype을 상속 받기 때문에 프로토타입 체인의 종점이라고 한다.
```

| 구분            | 설명                                 |
| --------------- | ------------------------------------ |
| 프로토타입 체인 | 상속과 프로퍼티 검색을 위한 매커니즘 |
| 스코프 체인     | 식별자 검색을 위한 매커니즘          |

<br />

## 🏷 오버라이딩과 프로퍼티 섀도잉

```
- 프로토타입 프로퍼티와 동일한 이름의 프로퍼티를 인스턴스에 추가하면 => 프로토타입 체인을 따라 검색해서 => 인스턴스 프로퍼티로 추가
- 프로퍼티 섀도잉: 인스턴스 메서드가 동일한 이름의 프로토타입 메서드를 오버라이딩하면 프로토타입 메서드는 가려진다.
```

<br />

## 🏷 프로토타입의 교체

```
- 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체 가능
```

### 9.1 생성자 함수에 의한 프로토타입 교체

```
- 프로토타입 교체 => constructor 프로퍼티와 생성자 함수 간의 연결 파괴
- 연결 복구 => 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티 복구
```

### 9.2 인스턴스에 의한 프로토타입 교체

```
- 생성자 함수의 prototype 프로퍼티에 다른 객체를 바인딩하는 것 => 미래에 생성할 인스턴스의 프로토타입 교체
- __proto__ 접근자 프로퍼티를 통해 프로토타입 교체 => 이미 생성된 객체의 프로토타입 교체
```

<br />

## 🏷 instanceof 연산자

> 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인하는 연산자

```
- 객체 instanceof 생성자함수
- 우변의 prototype에 바인딩된 객체가 좌변의 프로토타입 체인 상에 존재 여부에 따라 true/false(boolean)로 평가
```

```jsx
const Person = (function () {
  function Perrson(name) {
    this.name = name;
  }

  Person.prototype = {
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    },
  };
})();

const me = new Person('Lee');
console.log(me.contructor === Person); // false
console.log(me instanceof Person); // true
console.log(me instanceof Object); // true
```

<br />

## 🏷 직접 상속

### 11.1 Object.create에 의한 직접 상속

```
- Object.create 메서드는 명시적으로 프로토타입 지정, 새로운 객체 생성
- 첫번째 매개변수: 생성할 객체의 프로토타입으로 지정할 객체 전달
- 두번째 매개변수: 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립트 객체로 이루어진 객체 전달
- 장점: new 연산자 없어도 됨, 프로토타입 지정하면서 객체 생성 가능, 객체 리터럴에 의해 생성된 객체도 상속 가능
```

### 11.2 객체 리터럴 내부에서 \_\_proto\_\_에 의한 직접 상속

```
- Object.create은 두번째 인자로 프로퍼티를 정의하는 것이 번거롭기 때문에 __proto__ 접근자 프로퍼티를 사용하여 직접 상속하는 경우 쉽게 해결할 수 있다.
```

<br />

## 🏷 정적 프로퍼티/메서드

```
- 정적 프로퍼티/메서드: 인스턴스를 생성하지 않아도 참조 및 호출할 수 있는 프로퍼티/메서드
- 인스턴스의 프로토타입 체인에 속하지 않았기 때문에 인스턴스에 접근 불가
- 인스턴스/프로토타입 메서드 내에서 this 사용하지 않으면 정적 메서드로 변경 가능
```

```jsx
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

Person.staticProp = 'static prop';

Person.staticMethod = function () {
  console.log('staticMethod');
};

const me = new Person('Lee');

Person.staticMethod(); // staticMethod
me.staticMethod(); // TypeError
```

<br />

## 🏷 프로퍼티 존재 확인

### 13.1 in 연산자

> 객체 내에 특정 프로퍼티의 존재 여부 확인

```
- key in object
- key: 프로퍼티 키를 나타내는 문자열
- object: 객체로 평가되는 표현식
- 대상 객체의 프로퍼티 뿐만 아니라 상속 받은 모든 프로토타입의 프로퍼티 확인
- ES6에서는 Reflect.has 메서드 대신 사용 가능
```

### 13.2 Object.prototype.hasOwnProperty 메서드

> 객체 내에 특정 프로퍼티 존재 여부 확인

```
- 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우 true
- 상속받은 프로토타입의 프로퍼티 키인 경우 false
```

<br />

## 🏷 프로퍼티 열거

### 14.1 for...in문

> 모든 프로퍼티를 순회하며 열겨

```
- for (변수선언문 in 객체) {...}
- toString 프로퍼티의 프로퍼티 어트리뷰트 [[Enumerable]]는 false => 열거 불가
- 일반적인 for문, for...of문, Array.prototype.forEach 권장
```

### 14.2 Object.keys/values/entries 메서드

```
- Object.keys: 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환
- Object.values: 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환
- Object.entries: 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍을 배열에 담아 반환
```
