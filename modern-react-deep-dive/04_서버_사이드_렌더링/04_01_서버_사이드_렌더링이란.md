# 4. 서버 사이드 렌더링

## 🏷 서버 사이드 렌더링이란?

### 4.1.1 싱글 페이지 애플리케이션의 세상

- 렌더링과 라우팅에 필요한 대부분의 기능을 브라우저(js)에 의존하는 방식
- 첫 페이지에서 데이터 처리한 이후 모든 작업은 브라우저가 처리
- `<body />`에 내용이 없는 이유: js 코드로 삽입한 이후 렌더링하기 때문
- 단점: 최초 로딩해야할 js 리소스 증가

#### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

- 기존 웹 개발은 LAMP 스택 (linux, apache, mysql, php/python)
- 서버 의존적 문제 발생, 사용자 증가에 따라 서버 확장 부담
- JS 발전으로 인해 JAM 스택 사용 (Javascript, API, Markup)
- Node.js 고도화에 따라 MEAN, MERGN 스택처럼 API 서버 자체도 js로 구현하는 구조 생겨남

<br />

### 4.1.2 서버 사이드 렌더링이란?

- SSR Server Side Rendering
- 최초 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면 제공하는 방법

#### 서버 사이드 렌더링의 장점

- `최초 페이지 진입이 비교적 빠르다`
  - SPA: 리소스 다운 -> HTTP 요청 -> 화면 렌더링의 느린 과정
  - SSR: 서버 자체에서 HTTP 요청을 수행하기 때문에 더 빠름
- `검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다`
  - 검색 엔진 최적화에 유용
  - 검색 엔진 로봇은 페이지의 정적 정보를 가져오는 것이 목적이라서 다운로드/실행할 필요 없음
- `누적 레이아웃 이동이 적다`
  - 누적 레이아웃 이동: 페이지 표시 이후 특정 지점에서 페이지가 변경되어 불편을 초래하는 것
  - SPA: 모든 콘텐츠가 API 요청에 의존
  - SSR: 요청이 모두 완료된 이후 페이지를 제공
- `사용자의 디바이스 성능에 비교적 자유롭다`
  - JS 리소스는 디바이스에서만 실행되므로 의존적, SSR은 서버로 부담을 나눌 수 있어서 자유로움
  - 절대적인 것은 아님
- `보안에 좀 더 안전하다`
  - 민감한 정보가 노출될 수 있으나 SSR은 민감한 작업을 서버에서 수행하고 결과만 브라우저에 제공

#### 단점

- `소스코드를 작성할 때 항상 서버를 고려해야 한다`
  - window, sessionStorage는 브라우저에서만 지원
  - 이런 코드가 서버에서 실행되지 않도록 주의
- `적절한 서버가 구축돼 있어야한다`
  - SPA는 HTML만으로도 서비스할 수 있으나 SSR은 요청을 받을 서버가 필요
- `서비스 지연에 따른 문제`
  - SPA는 화면이 있는 상태에서 진행 중을 안내할 수 있음
  - SSR은 애초에 페이지가 없는 상태에서 문제가 생긴 것이기 때문에 안 좋은 사용자 경험 제공 가능성 높음

<br />

### 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

#### 싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션

- 가장 뛰어난 SPA는 가장 뛰어난 MPA보다 낫다.
- 평균적인 SPA는 평균적인 MPA보다 느리다.
- SPA는 렌더링과 라우팅에 최적화가 되어있지 않으면 성능이 일정하지 않을 수 있음
- MPA 라우팅 문제를 해결하기 위한 API가 추가되고 있음
  - 페인트 홀딩, back forward cache, Shared Element Transitions

#### 현대의 서버 사이드 렌더링

- 최초 웹사이트 진입 시에는 SSR로 완성된 HTML 제공 받음
- 라우팅에서는 JS를 바탕으로 SPA처럼 작동
- Next.js, Remix 등 SSR 프레임워크는 이런 방식으로 작동함
